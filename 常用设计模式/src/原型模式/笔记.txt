原型模式的优点
● 性能优良
原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一
个循环体内产生大量的对象时，原型模式可以更好地体现其优点。
● 逃避构造函数的约束
这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见13.4
节）。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑

原型模式的使用场景
● 资源优化场景
类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。
● 性能和安全要求的场景
通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
● 一个对象多个修改者的场景
一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑
使用原型模式拷贝多个对象供调用者使用。
在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的
方法创建一个对象，然后由工厂方法提供给调用者。原型模式已经与Java融为一体，大家可
以随手拿来使用。

原型模式的注意事项
原型模式虽然很简单，但是在Java中使用原型模式也就是clone方法还是有一些注意事项
的，我们通过几个例子逐个解说

构造函数不会被执行
一个实现了Cloneable并重写了clone方法的类A，有一个无参构造或有参构造B，通过
new关键字产生了一个对象S，再然后通过S.clone()方式产生了一个新的对象T，那么在对象
拷贝时构造函数B是不会被执行的

对象拷贝时构造函数确实没有被执行，这点从原理来讲也是可以讲得通的，Object类的
clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配
一个内存块，那构造函数没有被执行也是非常正常的了。

clone与final两个冤家粗体部分仅仅增加了一个final关键字，然后编译器就报斜体部分错误，正常呀，final类
               型你还想重赋值呀！你要实现深拷贝的梦想在final关键字的威胁下破灭了，路总是有的，我
               们来想想怎么修改这个方法：删除掉final关键字，这是最便捷、安全、快速的方式。你要使
               用clone方法，在类的成员变量上就不要增加final关键字。
               注意 要使用clone方法，类的成员变量上不要增加final关键字。

原型模式先产生出一个包含大量共有信息的类，然后可以拷贝出副本，修正细节信息，
建立了一个完整的个性对象。不知道大家有没有看过施瓦辛格演的《第六日》这部电影，电
影的主线也就是一个人被复制，然后正本和副本对掐。我们今天讲的原型模式也就是由一个
正本可以创建多个副本的概念。可以这样理解：一个对象的产生可以不由零起步，直接从一
个已经具备一定雏形的对象克隆，然后再修改为生产需要的对象。也就是说，产生一个人，
可以不从1岁长到2岁，再到3岁……也可以直接找一个人，从其身上获得DNA，然后克隆一
个，直接修改一下就是30岁了！我们讲的原型模式也就是这样的功能。
